// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package internal

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements mm_redis.Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGet          func(key string) (s1 string, err error)
	funcGetOrigin    string
	inspectFuncGet   func(key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mClientMockGet

	funcSet          func(key string, value string) (err error)
	funcSetOrigin    string
	inspectFuncSet   func(key string, value string)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mClientMockSet
}

// NewClientMock returns a mock for mm_redis.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMock = mClientMockGet{mock: m}
	m.GetMock.callArgs = []*ClientMockGetParams{}

	m.SetMock = mClientMockSet{mock: m}
	m.SetMock.callArgs = []*ClientMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockGet struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetExpectation
	expectations       []*ClientMockGetExpectation

	callArgs []*ClientMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetExpectation specifies expectation struct of the Client.Get
type ClientMockGetExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetParams
	paramPtrs          *ClientMockGetParamPtrs
	expectationOrigins ClientMockGetExpectationOrigins
	results            *ClientMockGetResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetParams contains parameters of the Client.Get
type ClientMockGetParams struct {
	key string
}

// ClientMockGetParamPtrs contains pointers to parameters of the Client.Get
type ClientMockGetParamPtrs struct {
	key *string
}

// ClientMockGetResults contains results of the Client.Get
type ClientMockGetResults struct {
	s1  string
	err error
}

// ClientMockGetOrigins contains origins of expectations of the Client.Get
type ClientMockGetExpectationOrigins struct {
	origin    string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mClientMockGet) Optional() *mClientMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Client.Get
func (mmGet *mClientMockGet) Expect(key string) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &ClientMockGetParams{key}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectKeyParam1 sets up expected param key for Client.Get
func (mmGet *mClientMockGet) ExpectKeyParam1(key string) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Client.Get
func (mmGet *mClientMockGet) Inspect(f func(key string)) *mClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mClientMockGet) Return(s1 string, err error) *ClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ClientMockGetResults{s1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Client.Get method
func (mmGet *mClientMockGet) Set(f func(key string) (s1 string, err error)) *ClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mClientMockGet) When(key string) *ClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	expectation := &ClientMockGetExpectation{
		mock:               mmGet.mock,
		params:             &ClientMockGetParams{key},
		expectationOrigins: ClientMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *ClientMockGetExpectation) Then(s1 string, err error) *ClientMock {
	e.results = &ClientMockGetResults{s1, err}
	return e.mock
}

// Times sets number of times Client.Get should be invoked
func (mmGet *mClientMockGet) Times(n uint64) *mClientMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of ClientMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mClientMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_redis.Client
func (mmGet *ClientMock) Get(key string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(key)
	}

	mm_params := ClientMockGetParams{key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetParams{key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("ClientMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ClientMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ClientMock.Get")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(key)
	}
	mmGet.t.Fatalf("Unexpected call to ClientMock.Get. %v", key)
	return
}

// GetAfterCounter returns a count of finished ClientMock.Get invocations
func (mmGet *ClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ClientMock.Get invocations
func (mmGet *ClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mClientMockGet) Calls() []*ClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *ClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mClientMockSet struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockSetExpectation
	expectations       []*ClientMockSetExpectation

	callArgs []*ClientMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockSetExpectation specifies expectation struct of the Client.Set
type ClientMockSetExpectation struct {
	mock               *ClientMock
	params             *ClientMockSetParams
	paramPtrs          *ClientMockSetParamPtrs
	expectationOrigins ClientMockSetExpectationOrigins
	results            *ClientMockSetResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockSetParams contains parameters of the Client.Set
type ClientMockSetParams struct {
	key   string
	value string
}

// ClientMockSetParamPtrs contains pointers to parameters of the Client.Set
type ClientMockSetParamPtrs struct {
	key   *string
	value *string
}

// ClientMockSetResults contains results of the Client.Set
type ClientMockSetResults struct {
	err error
}

// ClientMockSetOrigins contains origins of expectations of the Client.Set
type ClientMockSetExpectationOrigins struct {
	origin      string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mClientMockSet) Optional() *mClientMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for Client.Set
func (mmSet *mClientMockSet) Expect(key string, value string) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &ClientMockSetParams{key, value}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectKeyParam1 sets up expected param key for Client.Set
func (mmSet *mClientMockSet) ExpectKeyParam1(key string) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &ClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key
	mmSet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam2 sets up expected param value for Client.Set
func (mmSet *mClientMockSet) ExpectValueParam2(value string) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &ClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Client.Set
func (mmSet *mClientMockSet) Inspect(f func(key string, value string)) *mClientMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for ClientMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Client.Set
func (mmSet *mClientMockSet) Return(err error) *ClientMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &ClientMockSetResults{err}
	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the Client.Set method
func (mmSet *mClientMockSet) Set(f func(key string, value string) (err error)) *ClientMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Client.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Client.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the Client.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mClientMockSet) When(key string, value string) *ClientMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	expectation := &ClientMockSetExpectation{
		mock:               mmSet.mock,
		params:             &ClientMockSetParams{key, value},
		expectationOrigins: ClientMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up Client.Set return parameters for the expectation previously defined by the When method
func (e *ClientMockSetExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockSetResults{err}
	return e.mock
}

// Times sets number of times Client.Set should be invoked
func (mmSet *mClientMockSet) Times(n uint64) *mClientMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of ClientMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mClientMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_redis.Client
func (mmSet *ClientMock) Set(key string, value string) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(key, value)
	}

	mm_params := ClientMockSetParams{key, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := ClientMockSetParams{key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("ClientMock.Set got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("ClientMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("ClientMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the ClientMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(key, value)
	}
	mmSet.t.Fatalf("Unexpected call to ClientMock.Set. %v %v", key, value)
	return
}

// SetAfterCounter returns a count of finished ClientMock.Set invocations
func (mmSet *ClientMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of ClientMock.Set invocations
func (mmSet *ClientMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mClientMockSet) Calls() []*ClientMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*ClientMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *ClientMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDone() &&
		m.MinimockSetDone()
}
